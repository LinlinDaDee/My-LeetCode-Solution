# My-LeetCode-Solution
Collection of my solutions to LeetCode questions.
## Array
[0792-binary-search](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0792-binary-search) (boundary:[left,right])

[0027-remove-element](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0027-remove-element) (two pointers)

[0977-squares-of-a-sorted-array](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0977-squares-of-a-sorted-array) (two pointers)

[0209-minimum-size-subarray-sum](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0209-minimum-size-subarray-sum) (two pointers/sliding windows)

[0059-spiral-matrix-ii](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0059-spiral-matrix-ii) (循环不变量原则)
## Linked List
[0203-remove-linked-list-elements](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0203-remove-linked-list-elements) pointer in Java -- reference (操作指针必须是要删除的节点的上一个节点)

[0707-design-linked-list](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0707-design-linked-list) dummy_head

[0206-reverse-linked-list](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0206-reverse-linked-list) two pointers/recursion 
 
[0024-swap-nodes-in-pairs](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0024-swap-nodes-in-pairs) 操作指针的位置 & iteration 终止的判断条件

[0019-remove-nth-node-from-end-of-list](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0019-remove-nth-node-from-end-of-list) two pointers, the gap between first pointer and second pointer is n

[0160-intersection-of-two-linked-lists](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0160-intersection-of-two-linked-lists) two pointers 交换两个指针指向的链表使得两个指针在第二圈的时候traverse的节点数一样

[0142-linked-list-cycle-ii](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0142-linked-list-cycle-ii) two pointers -- fast & slow (相遇的判断和环入口的判断)
## Hash Table
当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法

[0242-valid-anagram](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0242-valid-anagram) hash(array) -- letters

[0349-intersection-of-two-arrays](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0349-intersection-of-two-arrays) HashSet

[0202-happy-number](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0202-happy-number) HashSet

[0001-two-sum](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0001-two-sum) HashMap

[0454-4sum-ii](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0454-4sum-ii) HashMap

[0383-ransom-note](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0383-ransom-note) hash(array) -- letters

[0015-3sum](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0015-3sum) two pointers -- 去重

[0018-4sum](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0018-4sum) two pointers -- 3 sum 再套一个 for 循环
##String
[0344-reverse-string](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0344-reverse-string) two pointers

[0541-reverse-string-ii](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0541-reverse-string-ii) for 循环每隔 2k 跳一次

[0151-reverse-words-in-a-string](https://github.com/LinlinDaDee/My-LeetCode-Solution/tree/main/0151-reverse-words-in-a-string) 1.去除多余空格 -> 2.整个字符串反转 -> 3.每个单词反转 
